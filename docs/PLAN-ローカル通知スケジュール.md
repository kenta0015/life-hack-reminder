# ローカル通知スケジュール 実装ロジック整理

## 方針（まとめ）

| 項目 | 内容 |
|------|------|
| **時間** | 毎日 **9:00** と **14:00** の2枠 |
| **誰を出すか** | 定着・淘汰（YES/NO/SKIP）＋**直近未表示ボーナス** |
| **同日重複防止** | 朝枠で選んだ itemId は昼枠の候補から除外 |
| **登録タイミング** | アプリ起動時・フォアグラウンド復帰時 |
| **21:00 通知** | 廃止し、9:00・14:00 に置き換え |

---

## 1. スケジュール構成

| 枠 | 時刻 | 役割イメージ |
|---|------|--------------|
| **朝枠** | 9:00 | 「よし、今日も頑張ろう」 |
| **昼枠** | 14:00 | 「よし、残りも気を引き締めて頑張ろう」（だれどきの刺激） |

- 毎日2通（9:00 と 14:00）
- 現在の「今日の1枚 21:00」は廃止し、上記2枠に置き換える

---

## 2. 「誰を出すか」のロジック

通知用に **`selectNextItemForNotification`** を新設（既存 `selectNextItem` を拡張する形）。

### 2-1. 選出の流れ

1. **クールダウン除外**: NO によるクールダウン中のアイテムは除外
2. **ベーススコア**: `baseScore = yesCount - 0.25 * skipCount`
3. **直近未表示ボーナス**: 最後に表示されてからの経過日数に応じて加算
   - `lastDeliveredAt` が無い（未表示）→ 最大ボーナス
   - 経過日数が多いほどボーナス大（例: `min(経過日数 * 0.5, 5)` など上限あり）
4. **合計スコア**: `totalScore = baseScore + recencyBonus`
5. **選択**: 合計スコア降順でソートし、同点グループからランダムに1件

### 2-2. 直近未表示ボーナス（具体例）

| 経過日数 | ボーナス例 |
|----------|------------|
| 未表示（lastDeliveredAt 無し） | +5 |
| 1日 | +0.5 |
| 3日 | +1.5 |
| 5日以上 | +2.5（上限） |

※ 係数・上限は実装時に調整可能。  
→ **定着したもの（baseScore 高）は依然有利**だが、**長く出ていないもの・新規はボーナスで出番が回る**。

### 2-3. クールダウン表（既存）

| NO 回数 | クールダウン日数 |
|---------|------------------|
| 1 | 5日 |
| 2 | 7日 |
| 3 | 9日 |
| 4以上 | 11日 |

### 2-4. YES/NO/SKIP の影響（既存）

| フィードバック | 効果 |
|----------------|------|
| **YES** | yesCount++、noCount が1減る（救済）→ 定着しやすい |
| **NO** | noCount++、クールダウン発生 → 淘汰に近づく |
| **SKIP** | skipCount++ → スコアが少し下がる |

---

## 3. 枠ごとの選出と「同じ日の複数通知」

- **朝枠（9:00）**: その時点の `selectNextItem(activeItems)` で1件選ぶ
- **昼枠（14:00）**: その時点の `selectNextItem(activeItems)` で1件選ぶ

**同じ日に朝と昼で別のアイテムが出る場合**  
→ 朝枠で選ばれたアイテムは `lastDeliveredAt` が更新されるため、昼枠ではそのアイテムのクールダウンが始まる（noCount=0 でも直後は同一日なので、朝と昼で同じアイテムが連続するのを防ぐには、**枠ごとに選出するタイミング**で `lastDeliveredAt` を使う必要がある）。

**実装上のポイント**  
- 通知を「登録する」タイミング: アプリ起動時・フォアグラウンド復帰時
- 9:00 と 14:00 の2本を登録する際、**それぞれの枠で「その日のその時刻」時点で誰を出すかをシミュレート**する必要はなく、**登録時点で `selectNextItem` を2回呼ぶ**形でよい
  - 1回目: 朝枠用の1件
  - 2回目: 1回目で選ばれたアイテムを除外するか、あるいは単純に「朝枠用」「昼枠用」の識別子を分けて、それぞれ `selectNextItem` で1件ずつ選ぶ
  - ただし `selectNextItem` は内部で `lastDeliveredAt` を使うので、朝枠で選んだあとに昼枠を選ぶと、朝枠で選んだアイテムは「直前に配信された」とみなされ、クールダウンは noCount に依存する。noCount=0 の場合はクールダウン0日なので、**同じアイテムが朝と昼の両方に出る可能性がある**。

**方針の整理**  
- 現状の `selectNextItem` は「直前の配信」情報を持たない（各アイテムの `lastDeliveredAt` は「そのアイテムが最後に配信された日時」）
- 朝9:00 で A を配信すると A の `lastDeliveredAt` が更新される
- 昼14:00 の登録時、A は noCount=0 ならクールダウン0日なので、まだ選ばれうる
- **同じ日に同じアイテムが2回出るのを防ぎたい場合**  
  - オプション1: 枠ごとに「今日すでに選んだ itemId」を覚えておき、2回目は除外する
  - オプション2: そのまま許容する（同じアイテムが朝・昼両方出ることもある）

ドキュメント上は **オプション1**（ same day の重複を防ぐ）を採用する想定で書く。

---

## 4. 具体例

### 4-1. アイテム一覧（ボーナス例: 未表示+5, 経過日数×0.5, 上限2.5）

| ID | タイトル | baseScore | lastDeliveredAt | 経過日数 | ボーナス | totalScore |
|----|----------|-----------|-----------------|----------|----------|------------|
| A | 朝のルーティン | 4.75 | 1日前 | 1 | +0.5 | 5.25 |
| B | 水分補給 | 2.5 | 6日前 | 6 | +2.5 | 5.0 |
| C | ストレッチ | 1 | - | - | - | **クールダウン中** |
| D | 深呼吸 | 0 | なし（未表示） | - | +5 | **5.0** |

### 4-2. 朝枠（9:00）の選出

- 除外: C（クールダウン中）
- 候補: A, B, D
- totalScore: A=5.25, B=5.0, D=5.0
- **選出: A**（最高スコア）

→ 9:00 の通知: 「Life Hack Reminder: 朝のルーティン」

### 4-3. 昼枠（14:00）の選出（同日）

- 朝枠で A を選んだとみなし、A を除外（同日重複防止）
- 除外: A（同日朝枠済み）, C（クールダウン中）
- 候補: B, D
- totalScore: B=5.0, D=5.0
- **選出: B または D**（同点ならランダム）

→ 14:00 の通知: 「Life Hack Reminder: 水分補給」または「深呼吸」

### 4-4. 直近未表示ボーナスの効き方

- **D（新規・未表示）**: baseScore=0 でもボーナス+5 で totalScore=5.0 → 出番が回る
- **B（6日未表示）**: baseScore=2.5 にボーナス+2.5 で 5.0 → 定着アイテムと拮抗
- **A（1日前表示）**: ボーナスは小さいが baseScore が高いので依然トップ

---

## 5. 登録のタイミング

- **アプリ起動時**: 当日の 9:00・14:00 が未過ぎなら、それぞれ1通ずつスケジュール
- **フォアグラウンド復帰時**: 同様に当日分を再計算し、既存をキャンセルして上書き登録

### 5-1. 過去時刻の扱い

- 9:00 を過ぎていたら 9:00 枠は登録しない
- 14:00 を過ぎていたら 14:00 枠は登録しない
- 両方過ぎていたら、その日は登録しない（翌日の登録は「翌日アプリ起動時」に行う）

### 5-2. 通知識別子

- 朝枠: `daily-9am` など固定 ID
- 昼枠: `daily-2pm` など固定 ID
- 登録前に同一 ID を `cancelScheduledNotificationAsync` でキャンセルしてから再登録

---

## 6. 通知タップ時の遷移（既存のまま）

- 通知の `content.data` に `itemId` を入れる
- タップ時: `addNotificationResponseReceivedListener` で受け取り、`/view?id=xxx` に遷移
- アイテムが削除済みならホームにフォールバック＋メッセージ表示

---

## 7. 変更・廃止するもの

| 項目 | 扱い |
|------|------|
| 「今日の1枚」21:00 | 廃止し、9:00・14:00 の2枠に置き換える |
| `scheduleTodayOneShot` | 9:00・14:00 用の `scheduleDailySlots` などに置き換え |
| `selectTodayItem`（日付シード） | 通知では使わない。ウィジェット用には継続 |

---

## 8. まとめ

1. **スケジュール**: 毎日 9:00 + 14:00（21:00 は廃止）
2. **誰を出すか**: 定着・淘汰（YES/NO/SKIP）＋**直近未表示ボーナス**（`selectNextItemForNotification`）
3. **同日重複**: 朝枠で選んだ itemId は昼枠の候補から除外
4. **登録タイミング**: 起動時・フォアグラウンド復帰時
5. **タップ遷移**: 既存どおり `/view?id=xxx` へ遷移

### 定着・淘汰との関係

- YES が多い → baseScore 高 → 出やすい（定着）
- NO が多い → クールダウン or 削除候補（淘汰）
- 長く出ていない or 未表示 → ボーナスで出番が回る（ローテーション）

---

## 9. 実装計画（段階的）

### 段階1: 選出ロジックの追加

| 項目 | 内容 |
|------|------|
| **目的** | 直近未表示ボーナス付きの `selectNextItemForNotification` を実装 |
| **変更ファイル** | `lib/delivery.ts`（または `lib/notificationSchedule.ts` に分離） |
| **やること** | `selectNextItemForNotification(items, excludeItemIds?: string[])` を追加。既存 `selectNextItem` はそのまま（配信シミュレート用）。 |
| **検証** | 単体テスト or 開発中に一時的に「配信シミュレート」から呼んで挙動確認。既存機能への影響なし。 |
| **完了条件** | ボーナスで新規・長期未表示のアイテムが選ばれうることを確認 |

---

### 段階2: 通知スケジュールの置き換え

| 項目 | 内容 |
|------|------|
| **目的** | 21:00 を廃止し、9:00・14:00 の2枠に置き換え |
| **変更ファイル** | `lib/notificationSchedule.ts`、`lib/AppContext.tsx` |
| **やること** | 1. `scheduleTodayOneShot` を `scheduleDailySlots` に置き換え（9:00・14:00 の2本を登録）<br>2. 選出に `selectNextItemForNotification` を使用（同日重複防止で excludeItemIds を渡す）<br>3. AppContext の呼び出しを `scheduleDailySlots` に変更 |
| **検証** | 実機でアプリ起動 → 当日の 9:00・14:00 が未過ぎなら通知が届く。タップで該当アイテムの詳細に遷移。 |
| **完了条件** | 9:00 と 14:00 に通知が届き、タップで詳細画面へ遷移することを確認 |

---

### 段階3: 設定画面・ドキュメントの更新

| 項目 | 内容 |
|------|------|
| **目的** | UI とドキュメントを新スケジュールに合わせる |
| **変更ファイル** | `app/settings.tsx`、必要なら `docs/PLAN-実機テストと将来仕様.md` 等 |
| **やること** | 1. 設定画面の「通知スケジュール」を「月・水・金 9:00」から「毎日 9:00・14:00」に変更<br>2. 補足文を更新 |
| **検証** | 設定画面の表示確認 |
| **完了条件** | 設定画面が新スケジュールを正しく表示している |

---

### 依存関係

```
段階1 ──→ 段階2 ──→ 段階3
         （段階1の selectNextItemForNotification を段階2で使用）
```

各段階完了後にコミットしてから次へ進むと、問題発生時にロールバックしやすい。
